# Brief Summary
I have been working as a software developer since the [end of the world](https://www.imdb.com/title/tt1190080/). 

# Tech traits
* If required, I don't hesitate to learn a new framework or even a new language.
* I have experience in new generation products as well as legacy products
* Have worked in various domains like banking, supply chain, retail, ad-tech and cyber security
* Apart from the whole front-end world, in the past I have worked on mainframes, jsp, db2, j2ee, websphere etc
* I don't have a personal favorite framework. I believe every framework has its use case

# Non Tech traits
* I can work as an individual contributor or as a team member
* People find me quite friendly and an open person
* I respect other's time. Try my best to join meetings on time
* Mistakes are just a part of development
* I respect skill irrespective of the experience
* I do not discriminate people on any basis
* Personal health comes first. Everything comes next
* I like people who evaluate your work depending on the quality of code and not the time taken to write it
* As with everybody else, I have some opinions but I try not to force them on others

<HR />

# संक्षिप्त विवरण
मैं [दुनिया के अंत] (https://www.imdb.com/title/tt1190080/) से एक सॉफ्टवेयर विकासक के रूप में कार्य कर रहा हूं।

# तकनीकी कौशल
* यदि आवश्यक हो, तो मैं एक नया ढांचा या एक नई भाषा सीखने में संकोच नहीं करता
* मुझे नई पीढ़ी के उत्पादों के साथ-साथ प्राचीन उत्पादों का भी अनुभव है
* बैंकिंग, आपूर्ति श्रृंखला, खुदरा, विज्ञापन-तकनीक और साइबर सुरक्षा जैसे विभिन्न कार्यक्षेत्र में अनुभव है
* फ्रंट-एंड के अलावा, अतीत में मैंने मेनफ्रेम, जेएसपी, डीबी टू, जेटूईई, वेबस्फीयर आदि पर भी काम किया है
* मेरा कोई व्यक्तिगत पसंदीदा ढांचा नहीं है। मेरा मानना ​​​​है कि हर ढांचे की अपनी उपयोगिता होती है 

# अंतर्वैयक्तिक कौशल
* मैं व्यक्तिगत योगदानकर्ता या समूह के सदस्य, दोनो स्तिथियों में काम करने में सक्षम हूँ
* लोग मुझे काफी मिलनसार और खुले विचारो वाला समझते हैं 
* मैं दूसरों के समय का सम्मान करता हूं, बैठकों में समय पर शामिल होने की पूरी कोशिश करता हूँ 
* मेरा मानना है कि गलतियाँ तो विकास का ही एक हिस्सा हैं
* मैं अनुभव को नहीं, कौशल को प्राथमिकता देता हूँ 
* मैं किसी भी आधार पर लोगों के साथ भेदभाव नहीं करता
* व्यक्तिगत स्वास्थ्य पहले आता है, सब कुछ उसके बाद 
* मुझे ऐसे लोग पसंद हैं जो कोड की गुणवत्ता के आधार पर आपके काम का मूल्यांकन करते हैं, न कि इसे लिखने में लगने वाले समय के आधार पर
* जैसा कि हर किसी के साथ होता है, मेरी भी कुछ अपनी राय हैं, लेकिन मैं पूरी कोशिश करता हूं कि उन्हें दूसरों पर थोपूँ नहीं 

`Experience`

# Qualys

## Summary

# Cyber security data analytics platform.
* Cyber Security - Everything is at risk!
* Analytics - Find patterns in data from multiple sources
* React - Build super scalable UI
* Redux - Complex apps needs a robust state management tool
* Figma - Photoshop can't do everything
* Kubernetes - Run hundreds of microservices with ease
* Docker - Cheap virtualization
* Elastic - Fast search needs Indexing  
* Kibana - Visualization for your indexed data
* Logstash - Processes data with lightning speed
* Hadoop - When your elastic becomes costly
* Kafka - Pub-Sub at scale

# साइबर सुरक्षा डेटा एनालिटिक्स प्लेटफॉर्म।
* साइबर सुरक्षा - सब कुछ जोखिम में है!
* विश्लेषिकी - कई स्रोतों से डेटा में पैटर्न खोजें
* रीऐक्ट - सुपर स्केलेबल यूआई बनाएं
* रीडक्स - जटिल ऐप्स को एक मजबूत स्टेट प्रबंधन टूल की आवश्यकता होती है
* फिगमा - फोटोशॉप सब कुछ नहीं कर सकता
* कुबेरनेट्स - सैकड़ों माइक्रोसर्विसेज को आसानी से चलाएं
* डॉकर - सस्ता वर्चुअलाइजेशन
* इलास्टिक - तेज़ खोज के लिए अनुक्रमण की आवश्यकता है
* किबाना - आपके अनुक्रमित डेटा के लिए विज़ुअलाइज़ेशन
* लॉगस्टैश - बिजली की गति के साथ डेटा संसाधित करता है
* हडूप - जब आपका इलास्टिक महंगा हो जाए
* काफ्का - पब-सब पर बड़े पैमाने पर

* **Cyber security** - My own qoute - If you are connected to internet, you are at risk! It doesn't matter if you have ten anti-virus installed, multiple firewalls in your network and your wifi protected with a WPA-2 key. You are always at risk. There is no way to reduce the risk to zero, but there are ways to make attacks more difficult for the hackers. All cyber security products try to minimize attacks and identify them as early as possible. Not all attacks are one shot, there could be an elaborate attack spanning across months or maybe year. Security needs to be built on every layer. `SSL` alone cannot protect you.

* **Analytics** - While you can run analytics on anything, analyzing data from security devices brings out some interesting patterns. There are products available in the market which can even predict the user behaviour. But for all this, you need a solid mechanism which retrieves, stores and process giga bytes of data daily. Detecting anomalous behaviour is one thing and detecting real concern is another. No tool is perfect but with advancement in technologies, you need to update continuously.

* **React** - Finally got chance to work on something which everyone was talking about. Well, every framework or library starts out as an internal tool and once it manages to solve a complex problem, it comes out as a instant solution to all problems. To be honest, `React` is not the solution to everything, but if you know React, you can create scalable apps pretty fast. By scalable, it means having hundreds of components which are inter-dependent. Of course as with any other complex solution, React brings with it, its own challenges. Learning the `props` and `state` is just the beginning. Without understanding the React's way of creating components, you can create a mess in even a trivial app.

* **Redux** - State management on UI have always been a headache. You create single page application, but your 300 components are inter connected. One change anywhere should instantly update the other and so on. This easily becomes messy when you start putting in multiple components on your page. You can always have a `window` property and do a re-render manually on any change in that property, but it won't be long that you will see inconsistent behaviour. With React's own state you are a bit closer but not enough. There comes a handy library which tells you one thing - Create a shared object and always update it by adding new properties to it via functions. On change this tool will tell React to re-render. Again, it comes with its own set of challenges. Its not easy to understand, specially when you are told to clone everything even if you are changing a small flag in a big array. It takes time to get comfortable with `Redux'

* **Figma** - Creating UI out of imagination is fine for your startup. But with enterprise systems, where you need consistency and everyone needs to be on the same page even before starting any implementation, you need a tool which can help visualize everyone what are they gonna build. Adobe's `Photoshop` was the goto tool when I started working, but now you need features which allow you to build your prototypes quickly and also provide interaction. `Invision` and `Figma` are such tools. They are cloud based so your designs are not lost and allow easy sharing. `Figma` works flawlessly in browsers too.

* **Kubernetes** - Another tool that started as an internal app and shortly became popular because of its efficiency. You want to run 500 microservices in distributed fault tolerant way. You can come up with your own service management or you can save time and use `k8s`. There is a learning curve and you need to move out of the mindset that service needs to be handled by you. You provide a configuration and `k8s` will handle everything from `replicas`, `routing` and auto scaling. 

* **Docker** - You have setup your project which runs on particular operating system with pre-defined libraries. But you want to change something and do not want to replicate the whole system. Docker containers are nothing but your whole operating system with your project deployed but without replicating the whole underlying operating system. Basically a cheap virualization system.

* **Elastic** - Indexing is the solution to almost every search problem. It all depends how you index and cache your data. `Elastic` is just another tool that helps you create an index which is fast and furious :-D.

* **Kibana** - Elastic stores your data and kibana gives you a visualization tool to see your data. Kibana is highly configurable and with in built support for elastic, becomes a perfect combo. You throw logs at it and start searching. It almost follows the same standard pattern of logging systems like a dashboard with aggregated values and a search page which enables you to create complex queries and search even that one error out of millions which pulled your production down.

* **Logstash** - Every electronic device creates a log. Depending on the log level, a small device like router can create thousands of entries in a span of minutes. If you are interested in running some algorigthm to find out patterns in logs, you need to read those logs from the router and store in your cloud. When you want to do this for hundreds of devices continuosly, you need something which parses the incoming data with lightning speed. `Logstash` is that tool.
With `Elastic`, `Logstash` and `Kibana` you get a combo known as `ELK stack` and is sufficient for majority of logging analytics and visualization.

* **Hadoop** - When you want to persist billions of records for a longer duration, no regular dbms or nosql storage can help. You need something that can compress and store with high efficiency. Retrieval time could be slow but in batches all operations should be fast. This is kind of what Mainframes used to do, but with more control and flexibility. Hadoop is not just one technology, instead a group of tools like `Spark`, `Hive`, `HDFS` and various other things.



# Mediaocean

# Summary

# Digital Ad management platform
* Ad Tech - Buy and sell ads on digital and legacy platform
* Knockout JS - Dependencies and observables create super fast UI
* Grunt - Automate your repetative tasks

# डिजिटल विज्ञापन प्रबंधन मंच
* एड टेक - डिजिटल और लीगेसी प्लेटफॉर्म पर विज्ञापन खरीदें और बेचें
* नॉकआउट जेएस - निर्भरता और अवलोकन सुपर फास्ट यूआई बनाते हैं
* ग्रंट - अपने दोहराए जाने वाले कार्यों को स्वचालित करें

* **Ad Tech** - We all know how search engines like google generate revenue. They offer products with `ads`. If you are not aware, every ad shown anywhere on screen is accounted for and is billed to the entity which had put bid for the place. Earlier it used to be simple since most of the ad business was static. You pay for pre defined space and position on the page. But with rapid demands a need came in to fine tune the ads. This made buying and selling of ads a complex activity and thus you need a system which can handle thousands of transactions and bill you exactly for the number of ads shown. `Mediaocean` had all the tools required for this business like `Prisma` for Buyer workflow and `Spectra/Ignitia` for finance. So next time you see a `Nike` ad on your goole search, don't ignore it. Note that somebody is paying for that one ad to be displayed just for you.

* **Knockout JS** - Creating complex forms where one value depends on other, which is quite frequent in any financial app, needs a robust mechanism for dependeny management. `KnockoutJS` was just the right tool for that. (P.S. - Yes, `React` can do the same thing, but the product was already created in Knockout and migrating to another framework was not something I was hired for). Knockout allowed us to create views with declarative bindings which in other words mean - html controls update the js inner models automatically and you don't need to listen for changes. You could also create observables which are dependent on other knockout observables. Any change in one of the observable and your other dependent values update themselves and thus re-render the UI.

* **Grunt** - When its just a few html and js files, you can manually manage the build process. But when you scale with hundreds of files and you need to add intermidiate steps like minimization, optimization etc, you need an automation tool. Just like webpack, grunt was one of the popular tools at that time. Its basically a task runner which automates your simples tasks like creating css files out of `sass` and `scss`. Bundling your images and js code into a single package etc. A good alternative to it is `Gulp` but it seems `webpack` is leading the way. There are some new tools like `vercel` but I am yet to try that out.

# Xpanxion

# Enterprise level Supply chain management
* Supply Chain Management - Inventory management, warehousing, replenishment etc.
* Java - Mar java mit java
* ExtJS - UI library of almost all the basic components you need
* Oracle - You need to store your data somewhere reliably

# आपूर्ति श्रृंखला प्रबंधन - सूची प्रबंधन, भंडारण, पुनःपूर्ति आदि।
* जावा - मार जावा मिट जावा :-D
* ई एक्स टी जेएस  - आपके लिए आवश्यक लगभग सभी बुनियादी घटकों की यू आइ लाइब्रेरी
* ओरकल - आपको अपने डेटा को कहीं मज़बूती से संग्रहीत करने की आवश्यकता है

* **Supply Chain Management** - The product was a complete platform for supply chain management from end to end including inventory management, warehousing, replenishment etc. One solution made it easy for the end customers to setup their whole supply chain without dealing with the integration of multiple systems. The power of the platform was that it could be configured using Eclipse without code changes.

* **Java** - Even though my primary work was around ExtJS, being a platform based out of java, it was necessary to know and work your way in backend too. 

* **ExtJS** - Around 2011, ExtJS was one of the popular frameworks which allowed rapid app development. You have your data apis available, just plugin the ExtJS components with those apis and voila - UI is ready. It gave you everything from textbox to grids to charts. Obviously it was licensed and thus companies are now moving away from it as costs increase.

* **Oracle** - You need the data to persist. This product used oracle.

# Accenture

# Summary

# Multi tenant Ecommerce platform
* Ecommerce - Amazon, Flipkart, TataCliq like systems
* Backbonejs - Create html views with model and restful apis
* Moustache - Create templates for your backbone views
* Webpack - Live reloading

# मल्टी टेनेंट ईकॉमर्स प्लेटफॉर्म
* ईकॉमर्स - ऐमज़ान, फ्लिपकार्ट, टाटा क्लिक जैसे सिस्टम
* बैकबोन जय ऐस - मॉडल और रेस्टफूल एपीआई के साथ एचटीएमएल व्यू बनाएं
* मुशतश - अपने बैकबोन व्यू के लिए टेम्प्लेट बनाएं
* वेबपैक - लाइव रीलोडिंग

* **Ecommerce** - The product was a multi tenant cloud based ecommerce portal which could be sold to customers who can then create their own ecommerce site with their customisations including themes, colors, logos and various other features.

* **Backbone JS** - Same as today, 2015 was also flooded with JS Frameworks - `React` was new, `Angular` was getting popular, `Knockout` was making it easy to create complex forms. `JQuery` and `bootstrap` were the de-facto libraries while creating any web app. `Backbone` was created around 2011(My college time), but was a good candidate for SPA application development where SEO didn't matter. It provided models and views with inbuilt restful support. Everything was done using events and subscribers. There was a small module `Backbone.Radio` which kind of acted like a common bus carrying all the messages. Since backbone only provided a mechanism of creating views, it was considered a library and not a framework. There was another tool on top of it called `Marionette` which enabled us to create some structure for our App.

* **Moustache** - When it comes to rendering complex UI, you need some kind of templating engine, otherwise creating the DOM becomes too cumbersome. We used `underscore` templates and then moved on to `Moustache` for better performance and more features.

* **Webpack** - This was the time I got introduced to the cutting edge tool - `webpack`. Through webpack only I became aware of live reloading. Coming from other languages like Java and dot net, getting your changes reflect almost instantly was a big change for me.


# Tata Consultancy Services

# Customer domain in Core Banking 
* Cobol - Common Business oriented language which has now become a special language
* Mainframes - Legacy hadoop
* Batching - Eventually you will run out of live processing power
* JCL - Control your batches
* Core Banking - Deposit and Withdraw
* Java - J2EE because POJO can't do everything
* Internet Banking - People need to shop online

# कोर बैंकिंग में ग्राहक डोमेन
* कोबोल - आम व्यापार उन्मुख भाषा जो अब एक विशेष भाषा बन गई है
* मेनफ्रेम - लिगेसी हडूप
* बैचिंग - आखिरकार आप लाइव प्रोसेसिंग पावर से बाहर हो जाएंगे
* जेसीएल - अपने बैचों को नियंत्रित करें
* कोर बैंकिंग - जमा और निकासी
* जावा - जे टू ई ई क्योंकि पोज़ो सब कुछ नहीं कर सकता
* इंटरनेट बैंकिंग - लोगों को ऑनलाइन खरीदारी करने की आवश्यकता है

* **COBOL** - It stands for Common Business Oriented Language. Well, if not `common`, but its certainly a special language. It appeared in 1959 when there was need of a language to process data for commercial purposes(that's why business oriented). Its special now because even today its [widely used](https://www.zdnet.com/article/cobol-turns-60-why-it-will-outlive-us-all/#:~:text=According%20to%20a%20COBOL%20consulting,code%20keeping%20the%20lights%20on).

* **Mainframes** - Mainframes were big systems used for bulk data processing since long ago. In other words, when portable computers were not powerful, large programs were run on big computers called Mainframes. Think of them as big data of that times. 

* **Batching** - While you can build everyday apps on any synchronous system, processing millions of transactions cannot be done live. When you scale, you need to start batching or as some people call it scheduling. Its not just for processing data, even [UI needs it now](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous).

* **JCL** - When you are scheduling thousands of jobs, you need a tool to manage those. JCL is a simple language which allows you to do that. It allows you to configure jobs and set things like what program to run, when to run and from where to pick the data.

* **Core Banking** - Banking systems are huge. They are generally divided into sub-systems like `Cards`, `Payments`, `Internet Banking`, `Core` etc. Customer Domain involves managing the customer's personal data like name, address, contacts, account info etc. You are not allowed to access customer's personal data and troubleshooting issues arising out of special characters in a name becomes a nightmare.

* **Java** - Mainframes were all fine when the bank operators used dummy terminals to connect them and log in to the system directly. Then there were desktop application which connected to mainframes via network. But with advancement in web application development, it became easier to work on any system via a browser. Thus we needed a web application that connects to the mainframe backend. This system was built using J2EE which connected to mainframes using IBM connectors.

* **Internet Banking** - Its same as other java based systems. A web application open for public which enables them to connect to backend systems. Of course, its not like every request goes to the mainframe. There are various optimizations done on each layer.

* **Customer Interaction** - When you are dealing with the customer directly, you need to understand what is the actual functional feature that is running behind the scenes. Irrespective of the problem, you need to find a solution and present it to the customer asap. The business should not stop!




# Common skills
* **Jenkins** - For repetative tasks instead of employing 5 people, you employ one person.
* **Git** - Code contribution and version management can't be more simpler and complex at the same time. I don't understand how commits work, but I know my way to work with my colleagues without breaking anything.
* **Postman** - I really wish could to do `POST` calls with modified payload in `chrome`, but untill then `postman` is the way to go.
* **Jira** - At home it helps in building the taste in our veggies, and in office it helps in building our projects:-D. `Jira` has become a default tool for project management. It offers everything you need to administer your product development. And as it is said, with great power comes great responsibility, you can easily messup in `Jira`. There are like hundreds of fields and every field has some significance. Your team needs to decide what all works for you.
* 